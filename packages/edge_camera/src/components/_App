<template>
    <Page>
        <ActionBar title="Welcome to NativeScript-Vue!" android:flat="true"/>
        <TabView android:tabBackgroundColor="#53ba82"
                 android:tabTextColor="#c4ffdf"
                 android:selectedTabTextColor="#ffffff"
                 androidSelectedTabHighlightColor="#ffffff">
            <TabViewItem title="Tab 1">
                <FlexboxLayout alignItems="flex-start" backgroundColor="#3c495e">
                    <Label class="message" :text="msg" col="0" row="0"/>
                    <Button text="getPicture" @tap="getPicture" />
                    <Button text="sensor test" @tap="takePicture" />
                </FlexboxLayout>
            </TabViewItem>
            <TabViewItem title="Tab 2">
                <FlexboxLayout alignItems="flex-start" backgroundColor="#3c495e">
                    <!-- <Label class="message" :text="accelerometerSensor" col="0" row="0"/> -->
                    <Button text="sensor test" @tap="startUpdatingHeading" />
                    <Button text="sensor stop" @tap="stopUpdatingHeading" />
                    <Label class="message" :text="degree" />
                </FlexboxLayout>
            </TabViewItem>
            <TabViewItem title="Tab 3">
                <FlexboxLayout columns="*" rows="*">
                    <!-- <Label class="message" :text="degree" /> -->
                    <!-- <Label class="message" :text="gyroScope" col="0" row="0"/> -->
                    <!-- <HtmlView html="<h1>Hello!</h1><input type='file' accept='image/*' capture='camera' />" /> -->
                    <!-- <CameraPlus height="250" /> -->
                    <!-- <Placeholder creatingView="onCreatingView" id="placeholder-view"/> -->
                    <!-- <CameraPlus ref="CameraPlus" height="600" id="camPlus"
                        saveToGallery="true"      
                        showCaptureIcon="true"
                        showGalleryIcon="false"
                        showToggleIcon="false"       
                        showFlashIcon="false"
                        debug="true"
                        enableVideo="false"
                        confirmVideo="false"
                        defaultCamera="front" /> -->
                        <!-- @loaded="onCameraLoaded"
                        @photoCapturedEvent="photoCaptured($event)"
                        @errorEvent="onCameraError">     
                    </CameraPlus> -->
                </FlexboxLayout>
            </TabViewItem>
        </TabView>
    </Page>
</template>

<script lang="ts">
import { Component, Vue } from "vue-property-decorator";
import * as app from "tns-core-modules/application";
import { isAndroid, /*isIOS*/ } from "tns-core-modules/platform";
// import * as camera from "nativescript-camera";
// import { Image } from "tns-core-modules/ui/image";

import * as permissions from "nativescript-permissions";
import * as utils from "tns-core-modules/utils/utils";

// import * as platform from "tns-core-modules/platform/platform";

interface ConfigCam {
    mCameraId: any,
    mCaptureSession: any,
    mCameraDevice: any,
    mStateCallBack: any,
    mBackgroundHandler: any,
    mCameraOpenCloseLock: any,
    mTextureView: any,
    mSurfaceTexture: any,
    mPreviewRequestBuilder: any,
    mPreviewRequest: any,
    mImageReader: any,
    mCaptureCallback: any,
    mFlashSupported: any,
    mFile: any,
}

declare const android: any;
declare const java: any;


@Component
export default class App extends Vue {
    private retries = 0;
    private msg = "Hello World!";
    private sensorUpdate;
    private sensorManager;
    private event;
    private cam: ConfigCam = Object.freeze({
        mCameraId: null,
        mCaptureSession: null,
        mCameraDevice: null,
        mStateCallBack: null,
        mBackgroundHandler: null,
        mCameraOpenCloseLock: new java.util.concurrent.Semaphore(1),
        mTextureView: null,
        mSurfaceTexture: null,
        mPreviewRequestBuilder: null,
        mPreviewRequest: null,
        mImageReader: null,
        mCaptureCallback: null,
        mFlashSupported: null,
        mFile: null,
    });
    

    // data() {
    //     return {
    //         retries: 0,
    //         msg: 'Hello World!',
    //         sensorUpdate: null,
    //         // sensorManager: null,
    //         // event: null,
    //         // captures: [],
    //         // imgReport: [],
    //         // frontCam: false,
    //         // webcam: null,
    //         // img: null,
    //         // camera: null,
    //         // deviceId: null,
    //         // devices: [],
    //         // cam: null
    //         //   googleKey: config.googleVisionKey
    //         cam: {
                
    //         }
    //     }
    // },
    mounted() {
        // this.sensors.setListener(this.sensorListener);
        // this.getAccelerometer();
        setTimeout(() => {
            // console.log("camManager: ", app.android.context.getSystemService("camera"));
            // console.log("context: ", app.android.context);
            this.getPicture();
        }, 2000);
        app.android.registerBroadcastReceiver(
            android.content.Intent.ACTION_SCREEN_OFF,
            () => {console.log("time ticked.")}
        );
        // console.log(app.android.context.CAMERA_SERVICE);
        // console.log(app.android.context.getSystemService(app.android.context.CAMERA_SERVICE));
    }

    get degree() {
        return this.event;
    }
    // computed: {
    //     degree() {
    //         return this.event;
    //     }
    // }
    // methods: {
    public receiverCallback(context, intent) {
        console.log("context: ", context);
        console.log("intent: ", intent);
    }

    public getPicture() {
        console.log("getting pictures...");
        if (!permissions.hasPermission(android.Manifest.permission.CAMERA)) {
            console.error("Application does not have permissions to camera");
            this.requestPermissions();
            this.retries += 1;
            if (this.retries < 5)
                setTimeout(() => {
                    this.getPicture();
                }, 3000);
            return;
        }
        let density = utils.layout.getDisplayDensity();

        let takePictureIntent = new android.content.Intent(android.provider.MediaStore.ACTION_IMAGE_CAPTURE);
        let dateStamp = this.createDateTimeStamp();

        console.log(density, takePictureIntent, dateStamp);

        // let sdkVersionInt = parseInt(platform.device.sdkVersion);

        // console.log("hw: ", JSON.stringify(android.hardware.camera2));
        // android.hardware
        // let cameraManager = android.hardware.camera2.CameraManager.getSystemService(app.android.context.CAMERA_SERVICE);
        // let cameraManager = app.android.context.getSystemService(android.content.Context.CAMERA_SERVICE);
        // let cameraManager = app.android.context.getSystemService(app.android.context.CAMERA_SERVICE);
        // let cameraManager = app.android.foregroundActivity.getSystemService(app.android.context.CAMERA_SERVICE);
        let cameraManager = app.android.context.getSystemService("camera");

        // console.log("number of cameras: ", cameraIdList.length);
        // console.log("context on getPicture(): ", context_sample);
        console.log("cameraManager: ", cameraManager);

        // let cameraIdList = JSON.parse(java.util.List(cameraManager.getCameraIdList()));
        let cameraIdList = JSON.parse(java.util.Arrays.toString(cameraManager.getCameraIdList()));
        // let path = cameraIdList.listFiles();
        // let facingList = [];

        console.log("Camera Id List: ", cameraIdList);
        // console.log("Camera Id path: ", path);


        if (cameraIdList.length == 0) {
            console.error("no cameras detected.");
            return;
        }

        let possibleCandidate;
        for (let c in cameraIdList) {
            // let characteristics = java.util.Objects.toString(cameraManager.getCameraCharacteristics(String(cameraIdList[c])));
            let characteristics = cameraManager.getCameraCharacteristics(String(cameraIdList[c]));
            let facing = characteristics.get(android.hardware.camera2.CameraCharacteristics.LENS_FACING);
            if  (facing != null && facing == android.hardware.camera2.CameraCharacteristics.LENS_FACING_FRONT)
                possibleCandidate = cameraIdList[c];
            // facingList.push(characteristics.LENS_FACING);
        }
        // cameraManager.openCamera(possibleCandidate, new android.hardware.camera2.CameraDevice.StateCallback.class());
        // cameraManager.openCamera(possibleCandidate, ()=> {});

        console.log("possibleCandidate: ", possibleCandidate);

        // i
        let MyStateCallback = android.hardware.camera2.CameraDevice.StateCallback.extend({
            onOpened(cameraDevice) {
                console.log("onOpened: " + cameraDevice);
                // this.cam
                
            }
        })

        console.log("MyStateCallback", MyStateCallback);

        // let stateCallback = new MyStateCallback();

        // StateCallback() {
        //     public onOpened(param0: android.hardware.camera2.CameraDevice): void;
            
        // });
        //  (cameraDevice) => {
        //     console.log("cameraDevice: ", cameraDevice);
        // })
        // console.log("facingList: ", facingList);

        // app.android.foregroundActivity.startActivityForResult(takePictureIntent, 3453);
    }

    public requestPermissions() {
        return permissions.requestPermissions([
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
            android.Manifest.permission.CAMERA
        ]);
    }

    public cameraActivity() {
            
    }

    public createDateTimeStamp() {
        let result = "";
        let date = new Date();

        result = date.getFullYear().toString() +
            ((date.getMonth() + 1) < 10 ? "0" + (date.getMonth() + 1).toString() : (date.getMonth() + 1).toString()) + (date.getDate() < 10 ? "0" + date.getDate().toString() : date.getDate().toString()) + "_" + date.getHours().toString() +
            date.getMinutes().toString() +
            date.getSeconds().toString();

        return result;
    }

    public onCameraLoaded(result) {
        this.cam = result.object;
        console.log("Camera loaded...");
    }

    // public onButtonCapture() {
    //     console.log('Take Picture');
    //     this.image = this.cam.takePicture({ saveToGallery: true });     
    // }

    public photoCaptured(args){
        console.log("ARGS - ", args)
    }

    public takePicture() {
        // camera.requestPermissions().then(() => {
        // this.msg = "Done permissioning";
        // setTimeout(() => {
        //     camera.takePicture().then(imageAsset => {
        //         console.log("Result is an image asset instance");
        //         this.msg = "Done taking picture";
        //         var image = new Image();
        //         image.src = imageAsset;
        //     }).catch(err => {
        //         console.log("Error: ", err.message);
        //         this.msg = "Error on taking picture";
        //     })
        // }, 5000);
        
        // });
    }

    public startUpdatingHeading() {
        if (this.sensorUpdate || this.sensorUpdate) {
            return;
        }
        if (isAndroid) {
            this.sensorManager = app.android.foregroundActivity.getSystemService(
                android.content.Context.SENSOR_SERVICE
            );

            this.sensorUpdate = new android.hardware.SensorEventListener({
                onAccuracyChanged: (sensor: any, accuracy: any) => {
                    console.log(accuracy, sensor)
                },
                onSensorChanged: (event: any) => {
                    // Here is the result we need for Android platform
                    // console.log(event.values[0]);
                    console.log(event.values[0], event.values[1], event.values[2]);
                    this.event = event;
                }
            });

            const orientationSensor = this.sensorManager.         getDefaultSensor(android.hardware.Sensor.TYPE_ROTATION_VECTOR);
            // const orientationSensor = this.sensorManager.         getDefaultSensor(android.hardware.Sensor.TYPE_ORIENTATION);
            
            this.sensorManager.registerListener(
                this.sensorUpdate,
                orientationSensor,
                android.hardware.SensorManager.SENSOR_DELAY_UI
            );
        }
    }

    public stopUpdatingHeading() {
        if (!this.sensorManager || !this.sensorUpdate) {
        return;
        }

        if (isAndroid) {
        this.sensorManager.unregisterListener(this.sensorUpdate);
        }

        this.sensorManager = null;
        this.sensorUpdate = null;
    }

    public getAccelerometer() {
        // this.accelerometerSensor = this.sensors.startSensor(android.hardware.Sensor.TYPE_LINEAR_ACCELERATION, SensorDelay.FASTEST);

        // // here we are using the android const 4 which is for the TYPE_GYROSCOPE sensor
        // // https://developer.android.com/reference/android/hardware/Sensor.html#TYPE_GYROSCOPE
        // // we are passing the third argument to `startSensor` which is for maxReportLatency, if the sensor is able to support FIFO this will register the sensor with the reporting latency value, if not, the sensor registers on the background thread as normal
        // this.gyroScope =  this.sensors.startSensor(4, SensorDelay.NORMAL, 4000000);

        // // maybe you wanna use a timeout and stop it after 8 seconds
        // setTimeout(() => {
        //     this.sensors.stopSensor(this.gyroScope);
        // }, 8000)
    }
}
</script>

<style scoped>
    ActionBar {
        background-color: #53ba82;
        color: #ffffff;
    }

    .message {
        vertical-align: center;
        text-align: center;
        font-size: 20;
        color: #333333;
    }
</style>
